From cb16ac8992051c9aa122ffa98b26123db65f2250 Mon Sep 17 00:00:00 2001
From: Moorthy Baskar <moorthy.baskaravenkatraman-sambamoorthy@linaro.org>
Date: Fri, 13 Sep 2019 08:33:20 +0200
Subject: [PATCH 1/2] wpeframework-ocdm-playready: linaro playready support

Signed-off-by: Moorthy Baskar <moorthy.baskaravenkatraman-sambamoorthy@linaro.org>
---
 CMakeLists.txt      |  7 +++++-
 MediaSession.cpp    | 56 ++++++++++++++++++++++++++-------------------
 MediaSession.h      |  5 +++-
 MediaSessionExt.cpp | 25 ++++++++++++++++++++
 MediaSystem.cpp     | 38 ++++++++++++++++++++++++++++++
 5 files changed, 105 insertions(+), 26 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b4ef98b..81f4c97 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -18,7 +18,9 @@ set_target_properties(${MODULE_NAME} PROPERTIES
         CXX_STANDARD 11
         CXX_STANDARD_REQUIRED YES)
 
+if (NETFLIX)
 include("${PLAYREADY_INCLUDE}/playready.cmake")
+endif()
 
 target_include_directories(${MODULE_NAME}
     PRIVATE
@@ -26,10 +28,13 @@ target_include_directories(${MODULE_NAME}
     "${CMAKE_SYSROOT}/usr/include/${NAMESPACE}"
     ${PLAYREADY_INCLUDE_DIRS})
 
-
+if (NETFLIX)
 target_link_libraries(${MODULE_NAME}
     PRIVATE
         PlayReady::PlayReady)
+endif()
+target_link_libraries(${MODULE_NAME}
+    ${PLAYREADY_LIBRARIES})
 
 # Library installation section
 set_target_properties(${MODULE_NAME} PROPERTIES SUFFIX ".drm")
diff --git a/MediaSession.cpp b/MediaSession.cpp
index 94fdcd2..2730a5e 100644
--- a/MediaSession.cpp
+++ b/MediaSession.cpp
@@ -63,7 +63,7 @@ const DRM_WCHAR g_rgwchCDMDrmStoreName[] = {WCHAR_CAST('/'), WCHAR_CAST('t'), WC
 const DRM_CONST_STRING g_dstrCDMDrmStoreName = CREATE_DRM_STRING(g_rgwchCDMDrmStoreName);
 
 #ifdef PR_3_3
-const DRM_CONST_STRING *g_rgpdstrRights[1] = {&g_dstrDRM_RIGHT_PLAYBACK};
+const DRM_CONST_STRING *g_rgpdstrRights[1] = {&g_dstrWMDRM_RIGHT_PLAYBACK};
 #else
 const DRM_CONST_STRING *g_rgpdstrRights[1] = {&g_dstrWMDRM_RIGHT_PLAYBACK};
 #endif
@@ -341,7 +341,11 @@ bool MediaKeySession::playreadyGenerateKeyRequest() {
                         DRM_NO_OF(g_rgpdstrRights),
                         _PolicyCallback,
                         nullptr,
+#ifdef NETFLIX
                         &m_oDecryptContext);
+#else
+                        m_oDecryptContext);
+#endif
 #endif
 
   // FIXME :  Check add case Play rights already acquired
@@ -503,11 +507,13 @@ CDMi_RESULT MediaKeySession::Decrypt(
         return CDMi_S_FALSE;
     }
     
-    DRM_RESULT err = DRM_SUCCESS;
+    DRM_RESULT dr = DRM_SUCCESS;
+    DRM_AES_COUNTER_MODE_CONTEXT ctrContext = { 0 };
+    DRM_DWORD rgdwMappings[2];
+
     if (!initWithLast15) {
 /* PRv3.3 support */
 #ifdef PR_3_3
-      DRM_DWORD rgdwMappings[2];
       if( f_pcbOpaqueClearContent == NULL || f_ppbOpaqueClearContent == NULL )
       {
           dr = DRM_E_INVALIDARG;
@@ -520,27 +526,29 @@ CDMi_RESULT MediaKeySession::Decrypt(
       ChkBOOL(m_eKeyState == KEY_READY, DRM_E_INVALIDARG);
       ChkArg(f_pbIV != NULL && f_cbIV == sizeof(DRM_UINT64));
 #else
-      err = Drm_Reader_InitDecrypt(m_oDecryptContext, nullptr, 0);
+      ChkDR(Drm_Reader_InitDecrypt(m_oDecryptContext, nullptr, 0));
 #endif
-    } else {
+    }
+#ifdef NETFLIX
+      else {
         // Initialize the decryption context for Cocktail packaged
         // content. This is a no-op for AES packaged content.
         if (payloadDataSize <= 15)
         {
-            err = Drm_Reader_InitDecrypt(m_oDecryptContext, (DRM_BYTE*)payloadData, payloadDataSize);
+            dr = Drm_Reader_InitDecrypt(m_oDecryptContext, (DRM_BYTE*)payloadData, payloadDataSize);
         }
         else
         {
-            err = Drm_Reader_InitDecrypt(m_oDecryptContext, (DRM_BYTE*)(payloadData + payloadDataSize - 15), payloadDataSize);
+            dr = Drm_Reader_InitDecrypt(m_oDecryptContext, (DRM_BYTE*)(payloadData + payloadDataSize - 15), payloadDataSize);
         }
     }
-    if (DRM_FAILED(err))
+#endif
+    if (DRM_FAILED(dr))
     {
         fprintf(stderr, "Failed to init decrypt\n");
         return CDMi_S_FALSE;
     }
 
-    DRM_AES_COUNTER_MODE_CONTEXT ctrContext = { 0 };
     // TODO: can be done in another way (now abusing "initWithLast15" variable)
     if (initWithLast15) {
         // Netflix case
@@ -569,17 +577,21 @@ CDMi_RESULT MediaKeySession::Decrypt(
     }
 
     ChkDR(Drm_Reader_DecryptOpaque(
+#ifdef NETFLIX
         &m_oDecryptContext,
+#else
+        m_oDecryptContext,
+#endif
         f_cdwSubSampleMapping,
         reinterpret_cast<const DRM_DWORD*>(f_pdwSubSampleMapping),
-        oAESContext.qwInitializationVector,
+        ctrContext.qwInitializationVector,
         payloadDataSize,
         (DRM_BYTE *) payloadData,
         reinterpret_cast<DRM_DWORD*>(f_pcbOpaqueClearContent),
         reinterpret_cast<DRM_BYTE**>(f_ppbOpaqueClearContent)));
 #else
-    err = Drm_Reader_Decrypt(m_oDecryptContext, &ctrContext, (DRM_BYTE*)payloadData, payloadDataSize);
-    if (DRM_FAILED(err))
+    ChkDR(Drm_Reader_Decrypt(m_oDecryptContext, &ctrContext, (DRM_BYTE*)payloadData, payloadDataSize));
+    if (DRM_FAILED(dr))
     {
         fprintf(stderr, "Failed to run Drm_Reader_Decrypt\n");
         return CDMi_S_FALSE;
@@ -589,7 +601,7 @@ CDMi_RESULT MediaKeySession::Decrypt(
     // Call commit during the decryption of the first sample.
     if (!m_fCommit) {
         //err = Drm_Reader_Commit(m_poAppContext, &opencdm_output_levels_callback, &levels_);
-        err = Drm_Reader_Commit(m_poAppContext, _PolicyCallback, nullptr); // TODO: pass along user data
+        ChkDR(Drm_Reader_Commit(m_poAppContext, _PolicyCallback, nullptr)); // TODO: pass along user data
         m_fCommit = TRUE;
     }
 
@@ -599,17 +611,13 @@ CDMi_RESULT MediaKeySession::Decrypt(
     *f_ppbOpaqueClearContent = (uint8_t *)payloadData;
 #endif
 
-/* PRv3.3 support */
-#ifdef PR_3_3
-        if( f_pcbOpaqueClearContent != NULL )
-          {
-              *f_pcbOpaqueClearContent = 0;
-          }
-          if( f_ppbOpaqueClearContent != NULL )
-          {
-              *f_ppbOpaqueClearContent = NULL;
-          }
-#endif
+ErrorExit:
+    if (DRM_FAILED(dr)) {
+      const DRM_CHAR* description;
+      DRM_ERR_GetErrorNameFromCode(dr, &description);
+      printf("playready error on Decrypt: %s\n", description);
+      return CDMi_S_FALSE;
+    }
 
     return CDMi_SUCCESS;
 }
diff --git a/MediaSession.h b/MediaSession.h
index 274079d..7f7ad6e 100644
--- a/MediaSession.h
+++ b/MediaSession.h
@@ -22,7 +22,6 @@
 #include <drmmathsafe.h>
 #include <drmtypes.h>
 #ifndef SIZEOF
-#define PR_3_3
 #define SIZEOF sizeof
 #include <drmcrt.h>
 #undef min
@@ -34,6 +33,10 @@
 #include <drmerr.h>
 #include <drmerror.h>
 
+#ifdef PR_3_3
+#include <drmversionconstants.h>
+#endif
+
 #undef __in
 #undef __out
 
diff --git a/MediaSessionExt.cpp b/MediaSessionExt.cpp
index 0fcfcaf..b4fb53f 100644
--- a/MediaSessionExt.cpp
+++ b/MediaSessionExt.cpp
@@ -14,13 +14,27 @@ using WPEFramework::Core::SafeSyncType;
 using WPEFramework::Core::CriticalSection;
 
 // The rights we want to request.
+#ifdef NETFLIX
 const DRM_WCHAR PLAY[] = { ONE_WCHAR('P', '\0'),
                            ONE_WCHAR('l', '\0'),
                            ONE_WCHAR('a', '\0'),
                            ONE_WCHAR('y', '\0'),
                            ONE_WCHAR('\0', '\0')
 };
+#else
+const DRM_WCHAR PLAY[] = { DRM_ONE_WCHAR('P', '\0'),
+                           DRM_ONE_WCHAR('l', '\0'),
+                           DRM_ONE_WCHAR('a', '\0'),
+                           DRM_ONE_WCHAR('y', '\0'),
+                           DRM_ONE_WCHAR('\0', '\0')
+};
+#endif
+
+#ifdef NETFLIX
 const DRM_CONST_STRING PLAY_RIGHT = CREATE_DRM_STRING(PLAY);
+#else
+const DRM_CONST_STRING PLAY_RIGHT = DRM_CREATE_DRM_STRING(PLAY);
+#endif
 static const DRM_CONST_STRING* RIGHTS[] = { &PLAY_RIGHT };
 
 namespace CDMi {
@@ -122,6 +136,7 @@ CDMi_RESULT MediaKeySession::StoreLicenseData(const uint8_t licenseData[], uint3
     // open scope for DRM_APP_CONTEXT mutex
     SafeSyncType<CriticalSection> systemLock(drmAppContextMutex_);
 
+#ifdef NETFLIX
     // Make sure PlayReady still expects a 16 byte array.
     ASSERT(TEE_SESSION_ID_LEN == 16);
 
@@ -170,6 +185,7 @@ CDMi_RESULT MediaKeySession::StoreLicenseData(const uint8_t licenseData[], uint3
     mSecureStopId.clear();
     mSecureStopId.resize(TEE_SESSION_ID_LEN);
     mSecureStopId.assign(secureStopId, secureStopId + TEE_SESSION_ID_LEN);
+#endif
 
     // All done.
     return CDMi_SUCCESS;
@@ -200,7 +216,9 @@ CDMi_RESULT MediaKeySession::InitDecryptContextByKid()
     if (m_decryptInited) {
         return CDMi_SUCCESS;
     }
+
     CDMi_RESULT result = CDMi_SUCCESS;
+#ifdef NETFLIX
     m_oDecryptContext = new DRM_DECRYPT_CONTEXT;
     //Create a decrypt context and bind it with the drm context.
     memset(m_oDecryptContext, 0, sizeof(DRM_DECRYPT_CONTEXT));
@@ -234,6 +252,7 @@ CDMi_RESULT MediaKeySession::InitDecryptContextByKid()
         fprintf(stderr, "Error: secure stop ID is not valid\n");
         result = CDMi_S_FALSE;
     }
+#endif
     return result;
 }
 
@@ -243,6 +262,7 @@ CDMi_RESULT MediaKeySession::GetChallengeDataExt(uint8_t * challenge, uint32_t &
 
     SafeSyncType<CriticalSection> systemLock(drmAppContextMutex_);
 
+#ifdef NETFLIX
     // sanity check for drm header
     if (mDrmHeader.size() == 0)
     {
@@ -308,6 +328,7 @@ CDMi_RESULT MediaKeySession::GetChallengeDataExt(uint8_t * challenge, uint32_t &
         fprintf(stderr, "Error: Drm_LicenseAcq_GenerateChallenge_Netflix returned 0x%lX\n", (long)err);
         return CDMi_OUT_OF_MEMORY ;
     }
+#endif
 
     return CDMi_SUCCESS;
 }
@@ -315,11 +336,13 @@ CDMi_RESULT MediaKeySession::GetChallengeDataExt(uint8_t * challenge, uint32_t &
 CDMi_RESULT MediaKeySession::CancelChallengeDataExt()
 {
     SafeSyncType<CriticalSection> systemLock(drmAppContextMutex_);
+#ifdef NETFLIX
     DRM_RESULT err = Drm_LicenseAcq_CancelChallenge_Netflix(m_poAppContext, &mNounce[0]);
     if (DRM_FAILED(err)) {
         fprintf(stderr, "Error Drm_LicenseAcq_CancelChallenge_Netflix: 0x%08lx\n", static_cast<unsigned long>(err));
         return CDMi_S_FALSE;
     }
+#endif
     return CDMi_SUCCESS;
 }
 
@@ -331,6 +354,7 @@ CDMi_RESULT MediaKeySession::CleanDecryptContext()
 
     CDMi_RESULT result = CDMi_SUCCESS;
 
+#ifdef NETFLIX
     // Seems like we no longer have to worry about invalid app context, make sure with this ASSERT.
     ASSERT(m_poAppContext != nullptr);
     if (m_oDecryptContext) {
@@ -403,6 +427,7 @@ CDMi_RESULT MediaKeySession::CleanDecryptContext()
             result = CDMi_S_FALSE;
         }
     }
+#endif
     if (m_poAppContext)
     {
         err = Drm_Reader_Commit(m_poAppContext, nullptr, nullptr);
diff --git a/MediaSystem.cpp b/MediaSystem.cpp
index b52c012..7e76d71 100644
--- a/MediaSystem.cpp
+++ b/MediaSystem.cpp
@@ -40,8 +40,13 @@ WPEFramework::Core::CriticalSection drmAppContextMutex_;
 static DRM_WCHAR* createDrmWchar(std::string const& s) {
     DRM_WCHAR* w = new DRM_WCHAR[s.length() + 1];
     for (size_t i = 0; i < s.length(); ++i)
+#ifdef PR_3_3
+        w[i] = DRM_ONE_WCHAR(s[i], '\0');
+    w[s.length()] = DRM_ONE_WCHAR('\0', '\0');
+#else
         w[i] = ONE_WCHAR(s[i], '\0');
     w[s.length()] = ONE_WCHAR('\0', '\0');
+#endif
     return w;
 }
 
@@ -118,6 +123,7 @@ public:
 
        SafeSyncType<CriticalSection> lock(drmAppContextMutex_);
 
+#ifdef NOT_AVAILABLE
        DRM_UINT64 utctime64;
        DRM_RESULT err = Drm_Clock_GetSystemTime(m_poAppContext.get(), &utctime64);
        if (err != DRM_SUCCESS) {
@@ -128,6 +134,7 @@ public:
            //*time = (time_t)utctime64;
            return (time_t)utctime64;
        }
+#endif
 
        return 0;
 
@@ -174,11 +181,13 @@ public:
         SafeSyncType<CriticalSection> lock(drmAppContextMutex_);
 
         uint32_t ldlLimit = 0;
+#ifdef NOT_AVAILABLE
         DRM_RESULT err = Drm_LicenseAcq_GetLdlSessionsLimit_Netflix(m_poAppContext.get(), &ldlLimit);
         if (err != DRM_SUCCESS) {
             fprintf(stderr, "Error: Drm_LicenseAcq_GetLdlSessionsLimit_Netflix returned 0x%lX\n", (long)err);
             return 0;
         }
+#endif
 
         return ldlLimit;
     }
@@ -186,13 +195,19 @@ public:
     bool IsSecureStopEnabled() override
     {
         SafeSyncType<CriticalSection> lock(drmAppContextMutex_);
+#ifdef NOT_AVAILABLE
         return static_cast<bool>(Drm_SupportSecureStop());
+#else
+        return false;
+#endif
     }
 
     CDMi_RESULT EnableSecureStop(bool enable) override
     {
         SafeSyncType<CriticalSection> lock(drmAppContextMutex_);
+#ifdef NOT_AVAILABLE
         Drm_TurnSecureStop(static_cast<int>(enable));
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -200,16 +215,21 @@ public:
     uint32_t ResetSecureStops() override
     {
         SafeSyncType<CriticalSection> lock(drmAppContextMutex_);
+
+#ifdef NOT_AVAILABLE
         // if secure stop is not supported, return
         DRM_BOOL supported = Drm_SupportSecureStop();
         if (supported == FALSE)
             return 0;
+#endif
 
         DRM_WORD numDeleted = 0;
+#ifdef NOT_AVAILABLE
         DRM_RESULT err = Drm_ResetSecureStops(m_poAppContext.get(), &numDeleted);
         if (err != DRM_SUCCESS) {
             fprintf(stderr, "Drm_ResetSecureStops returned 0x%lx\n", (long)err);
         }
+#endif
         return numDeleted;
     }
 
@@ -217,6 +237,7 @@ public:
     {
         SafeSyncType<CriticalSection> lock(drmAppContextMutex_);
 
+#ifdef NOT_AVAILABLE
         // if secure stop is not supported, return NotAllowed
         DRM_BOOL supported = Drm_SupportSecureStop();
         if (supported == FALSE)
@@ -232,6 +253,7 @@ public:
         for (int i = 0; i < count; ++i) {
             memcpy(&ids[i * TEE_SESSION_ID_LEN], sessionIds[i], TEE_SESSION_ID_LEN);
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -244,6 +266,7 @@ public:
     {
         SafeSyncType<CriticalSection> lock(drmAppContextMutex_);
 
+#ifdef NOT_AVAILABLE
         // if secure stop is not supported, return
         DRM_BOOL supported = Drm_SupportSecureStop();
         if (supported == FALSE)
@@ -265,6 +288,7 @@ public:
             fprintf(stderr, "Drm_GetSecureStop(0) returned 0x%lx\n", (long)err);
             return CDMi_S_FALSE;
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -277,6 +301,7 @@ public:
     {
         SafeSyncType<CriticalSection> lock(drmAppContextMutex_);
 
+#ifdef NOT_AVAILABLE
         // if secure stop is not supported, return
         DRM_BOOL supported = Drm_SupportSecureStop();
         if (supported == FALSE)
@@ -298,6 +323,7 @@ public:
         {
             fprintf(stderr, "Drm_CommitSecureStop returned 0x%lx\n", (long)err);
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -339,6 +365,7 @@ public:
 
         DRM_RESULT err;
 
+#ifdef NOT_AVAILABLE
         // DRM Platform Initialization
         err = Drm_Platform_Initialize();
         if(DRM_FAILED(err))
@@ -375,6 +402,7 @@ public:
             fprintf(stderr, "Error in Drm_Revocation_SetBuffer: 0x%08lX\n", err);
             return CDMi_S_FALSE;
         }
+#endif
 
         //return ERROR_NONE;
         return CDMi_SUCCESS;
@@ -389,6 +417,7 @@ public:
             return CDMi_S_FALSE;
         }
 
+#ifdef NOT_AVAILABLE
         DRM_RESULT err;
         err = Drm_Reader_Commit(m_poAppContext.get(), nullptr, nullptr);
         if(DRM_FAILED(err)) {
@@ -414,6 +443,7 @@ public:
             fprintf(stderr, "Failed to call Drm_Platform_Unitialize\n");
             return CDMi_S_FALSE;
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -422,12 +452,14 @@ public:
     {
         SafeSyncType<CriticalSection> lock(drmAppContextMutex_);
 
+#ifdef NOT_AVAILABLE
         DRM_RESULT err = Drm_DeleteKeyStore();
         if (err != DRM_SUCCESS)
         {
             fprintf(stderr, "Error: Drm_DeleteKeyStore returned 0x%lX\n", (long)err);
             return CDMi_S_FALSE;
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -436,12 +468,14 @@ public:
     {
         SafeSyncType<CriticalSection> lock(drmAppContextMutex_);
 
+#ifdef NOT_AVAILABLE
         DRM_RESULT err = Drm_DeleteSecureStore(&drmStore_);
         if (err != DRM_SUCCESS)
         {
             fprintf(stderr, "Error: Drm_DeleteSecureStore returned 0x%lX\n", (long)err);
             return CDMi_S_FALSE;
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -458,12 +492,14 @@ public:
             return CDMi_S_FALSE;
         }
 
+#ifdef NOT_AVAILABLE
         DRM_RESULT err = Drm_GetKeyStoreHash(keyStoreHash);
         if (err != DRM_SUCCESS)
         {
             fprintf(stderr, "Error: Drm_GetSecureStoreHash returned 0x%lX\n", (long)err);
             return CDMi_S_FALSE;
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -480,12 +516,14 @@ public:
             return CDMi_S_FALSE;
         }
 
+#ifdef NOT_AVAILABLE
         DRM_RESULT err = Drm_GetSecureStoreHash(&drmStore_, secureStoreHash);
         if (err != DRM_SUCCESS)
         {
             fprintf(stderr, "Error: Drm_GetSecureStoreHash returned 0x%lX\n", (long)err);
             return CDMi_S_FALSE;
         }
+#endif
 
         return CDMi_SUCCESS;
     }
-- 
2.17.1

